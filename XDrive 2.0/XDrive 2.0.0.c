#pragma config(Sensor, dgtl1,  NEencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  SEencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  SWencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  NWencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  ESTOPbtn,       sensorTouch)
#pragma config(Sensor, dgtl10, ,               sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, lampENABLE,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, lampESTOP,      sensorLEDtoVCC)
#pragma config(Motor,  port3,           NE,            tmotorVex393_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port4,           SE,            tmotorVex393_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port5,           SW,            tmotorVex393_MC29, openLoop, encoderPort, dgtl5)
#pragma config(Motor,  port6,           NW,            tmotorVex393_MC29, openLoop, encoderPort, dgtl7)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------*\
|*			SETUP			*|
\*----------------*/

const float tol = 5; //+-5 joystick inputs from 0
const float botMaxSpeed = 127;
const float speedSmoothing = 0.001;
const float motorAngle[4] = {135, -135, -45, 45};
const float tps = 10;

bool hybernate = false;
int hybernateCount = 0;
int timeTillHybernate = 5; //# seconds

bool eStopState = false;
//LEDs
int ledESTOP = 1;	//Start out Slow Blink
int ledEnable = 0; //Start out OFF

//Controller
float contrlLatDir = 0.0;
float contrlLatMag = 0.0;
			//float contrlRotMag = 0.0; //Same as rotateMag

//Added
float lateralMag[4] = {0.0, 0.0, 0.0, 0.0};
float rotateMag = 0.0;

//Convert
string motorName[4] ={
	"NE",
	"SE",
	"SW",
	"NW",
};
float percent[4] ={
	1.0, 1.0, 1.0, 1.0
};
float powerMult[4] ={
	1.0, 1.0, 1.0, 1.0
};


//Speeds
float targetSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};

float smoothSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};


/*----------------*\
|*		FUNCTIONS		*|
\*----------------*/

float lerp(float a, float b, float weight)	//Acceleration equation
{
	return a * (1 - weight) + b*weight;
}



			//For LeftJoyDir
			float pythag(float a, float b)
			{
				float c = sqrt( (a*a) + (b*b) );
				if (c < tol && c > -tol)
				{
					return 0;
				}
				else
				{
					return c;
				}
			}
			float arcTangent(float adj, float opp)
			{
				if (adj == 0)
				{
					adj = 0.01;
				}
				float degree = atan(opp / adj);
				if (degree < tol && degree > -tol)
				{
					degree = 0;
				}
				return degree;	//Adjust for quadrents
			}
			float cosine(float hyp, float degree)
			{
				float adj = hyp * cos(degree); //Lateral movement speed is the bot's lateralMag times cosine of the lateralDir
				if (abs(degree) != degree)
				{
					adj *= -1;	//Flip to negative
				}
				if (adj < tol && adj > -tol)
				{
					adj = 0;	//Round to zero
				}
				return adj;
			}//For LeftJoyDir


		//For determineLat
		float leftJoyDir()
		{
			return arcTangent(vexRT[Ch3], vexRT[Ch4]);
		}
		float leftJoyMag()
		{
				return pythag(vexRT[Ch3], vexRT[Ch4]);
		}//For determineLat


	//For addLatRot
	void determineLat()
	{
		float latTargetDir = (leftJoyDir());	//Get left joystick direction & magnitude
		float latTargetMag = (leftJoyMag());

		for (int i = 0; i < 4; i++)
		{
			lateralMag[i] = cosine(latTargetMag, abs(motorAngle[i] - latTargetDir) );	//Cosine of magnitude and degree
		}
	}
	void determineRot()
	{
		if (vexRT[Ch1] <= tol && vexRT[Ch1] >= -tol)
		{
			rotateMag = 0;
		}
		else
		{
			rotateMag = vexRT[Ch1] / 127; //Ch1 Percent
		}
	}//For addLatRot


void addLatRot()
{
	for (int i = 0; i < 4; i++)
	{
		percent[i] = lateralMag[i] + rotateMag;	//The percent speed each motor should travel at, between 200% and -200%
	}
}

void convertForTargetSpeed()	//string motorName, float percent, float powerMult, float botMaxSpeed
{
	float denom = 1.00;		//Percents are out of 100% by default

	for (int i = 0; i < 4; i++)
	{
		percent[i] = percent[i] * powerMult[i];	//Apply the multiplier for fast/slow motors
		if ( abs(percent[i]) > denom)	//if the percent is greater than the denominator, yielding more than 100%
		{
			denom = abs(percent[i]);	//make the denominator equal to the new percent, so no value is more than 100%
		}
	}

	for (int i = 0; i < 4; i++)
	{
		targetSpeeds[i] = (percent[i] / denom) * botMaxSpeed;	//The target speed is a value between 0 and 1 representing the percent
	}																												//times the max speed the bot should ever travel at
}

void convertAndOutputSmoothSpeed()
{
	for (int i = 0; i < 4; i++)
	{
		smoothSpeeds[i] = lerp(smoothSpeeds[i], targetSpeeds[i], speedSmoothing);	//Find the speed with acceleration
		motor[motorName[i]] = smoothSpeeds[i];	//Output to motors
	}
}


void calculateAll()
{
	determineLat();
	determineRot();

	if (contrlLatDir == 0 && contrlLatMag == 0 && rotateMag == 0)
	{
		for (int i = 0; i < 4; i++)
		{
			targetSpeeds[i] = 0;
			hybernateCount++;
			if (hybernateCount >= tps * timeTillHybernate)	//If timeTillHybernate seconds spent inactive
			{
				hybernate = true;			//Enable hybernate
			}
		}
	}
	else
	{
		hybernate = false;				//Disable hybernate
		addLatRot();							//lateralMag, rotateMag
		convertForTargetSpeed();	//motorName, percent, powerMult, botMaxSpeed
	}

	convertAndOutputSmoothSpeed();
}



/*----------------*\
|*			Main			*|
\*----------------*/

task main()
{
	ledEnable = 1;	//SlowBlink
	//updateLED();
	while (true)
	{

		/*if ( (vexRT[Btn5U] && vexRT[Btn6U]) || (vexRT[Btn5D] && vexRT[Btn6D]) )
		{
			ledEnable = 3;	//ON
			ledESTOP = 1;	//Slow Blink

			if (SensorValue(ESTOPbtn) == 0)
			{
				eStopState = true;
				ledESTOP = 3;	//ON
				ledEnable = 0;	//OFF
			}

			if (!eStopState)
			{
				calculateAll();

				if (hybernate)
				{
					wait1Msec(1000 / 2); //2 ticks per second
				}
				else
				{
					wait1Msec(1000 / tps);	//Msec per tick, inverse of ticks per second
				}
			}
			else
			{
				ledEnable = 1;	//Slow Blink
				break;
			}

		}	//While Enable*/
		calculateAll();
		wait1Msec(1000 / tps);	//Msec per tick, inverse of ticks per second

	}	//While Wait For Enable
}	//Task Main
