#pragma config(Motor,  port3,           NE,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           SE,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           SW,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           NW,            tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float tol = 5; //+-5 joystick inputs from 0
const float botMaxSpeed = 127;
const float speedSmoothing = 0.001;
const float motorAngle[4] = {135, -135, -45, 45}; //*	? ???    or ? ?? ?? ???
																									//* ?? ??

//Controller
float contrlLatDir = 0.0;
float contrlLatMag = 0.0;
			//float contrlRotMag = 0.0; //Same as rotateMag

//Added
float lateralMag[4] = {0.0, 0.0, 0.0, 0.0};
float rotateMag = 0.0;

//Convert
string motorName[4] ={
	"NE",
	"SE",
	"SW",
	"NW",
};
float percent[4] ={
	1.0, 1.0, 1.0, 1.0
};
float powerMult[4] ={
	1.0, 1.0, 1.0, 1.0
};


//Speeds
float targetSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};

float smoothSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};




float lerp(float a, float b, float weight)
{
	return a * (1 - weight) + b*weight;
}

float pythag(float a, float b)
{
	float c = sqrt( (a*a) + (b*b) );
	if (c < tol && c > -tol)
	{
		return 0;
	}
	else
	{
		return c;
	}
}

float tangent(float adj, float opp)
{
	if (adj == 0)
	{
		adj = 0.01;
	}
	float degree = atan(opp / adj);
	if (degree < tol && degree > -tol)
	{
		degree = 0;
	}
	return degree;	//Adjust for quadrents
}



float leftJoyDir()
{
	return tangent(vexRT[Ch3], vexRT[Ch4]);
}

float leftJoyMag()
{
		return pythag(vexRT[Ch3], vexRT[Ch4]);
}


void determineLat()
{
	float latTargetDir = (leftJoyDir());
	float latTargetMag = (leftJoyMag());

	for (int i = 0; i < 4; i++)
	{
		lateralMag[i] = abs(motorAngle[i] - latTargetDir);
	}
}

void determineRot()
{
	if (vexRT[Ch1] <= tol && vexRT[Ch1] >= -tol)
	{
		rotateMag = 0;
	}
	else
	{
		rotateMag = vexRT[Ch1];
	}
}


void addLatRot()							//float lat, float rot
{
	for (int i = 0; i < 4; i++)
	{
		percent[i] = lateralMag[i] + rotateMag;
	}
}

void convertForTargetSpeed()	//string motorName, float percent, float powerMult, float botMaxSpeed
{
	float denom = 1.00;

	for (int i = 0; i < 3; i++)
	{
		percent[i] = percent[i] * powerMult[i];
		if ( abs(percent[i]) > 1.00 )
		{
			denom = abs(percent[i]);
		}
	}

	for (int i = 0; i < 4; i++)
	{
		targetSpeeds[i] = (percent[i] / denom) * botMaxSpeed;
	}
}

void convertAndOutputSmoothSpeed()
{
	for (int i = 0; i < 4; i++)
	{
		smoothSpeeds[i] = lerp(smoothSpeeds[i], targetSpeeds[i], speedSmoothing);
		motor[motorName[i]] = smoothSpeeds[i];
	}
}

task main()
{
	determineLat();
	determineRot();

	if (contrlLatDir == 0 && contrlLatMag == 0 && rotateMag == 0)
	{
		for (int i = 0; i < 4; i++)
		{
			targetSpeeds[i] = 0;
		}
	}
	else
	{
		addLatRot();							//lateralMag, rotateMag
		convertForTargetSpeed();	//motorName, percent, powerMult, botMaxSpeed
	}

	convertAndOutputSmoothSpeed();
}











	/*while (true)
	{
		if ( (vexRT[Btn5U] || vexRT[Btn5D]) && (vexRT[Btn6U] || vexRT[Btn6U]) ) //Press the two top buttons to activate the code
		{

		}
	}*/

		/*if (motorName == null)
	{
		System.out.println("ERROR: undefined motor name");
	}*/

		/*switch()
	{
	case CONDITION:*/
