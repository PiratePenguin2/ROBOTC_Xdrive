#pragma config(Sensor, dgtl1,  NEencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  SEencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  SWencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  NWencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  ESTOPbtn,       sensorTouch)
#pragma config(Sensor, dgtl10, ,               sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, lampENABLE,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, lampESTOP,      sensorLEDtoVCC)
#pragma config(Motor,  port3,           NE,            tmotorVex393_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port4,           SE,            tmotorVex393_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port5,           SW,            tmotorVex393_MC29, openLoop, encoderPort, dgtl5)
#pragma config(Motor,  port6,           NW,            tmotorVex393_MC29, openLoop, encoderPort, dgtl7)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*----------------*\
|*			SETUP			*|
\*----------------*/

const float tps = 10;
//const float speedSmoothing = 0.25;
const float tol = 10;
const float botMaxSpeed = 127;
const float motorAngle[4] = {135, -135, -45, 45};

bool eStopState = false;

//Added
float lateralMag[4] = {0.0, 0.0, 0.0, 0.0};
float rotateMag = 0.0;

//Convert
float percent[4] ={
	0.0, 0.0, 0.0, 0.0
};
float powerMult[4] ={
	1.75, 1.0, 1.0, 1.0
};

//Speeds
float targetSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};
float smoothSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};



/*----------------*\
|*		FUNCTIONS		*|
\*----------------*/


				/*float lerp(float a, float b, float weight)	//Acceleration equation
				{
					return a * (1 - weight) + b*weight;
				}*/
				void updateMotors()
				{
					motor[NE] = smoothSpeeds[0];
					motor[SE] = smoothSpeeds[1];
					motor[SW] = smoothSpeeds[2];
					motor[NW] = smoothSpeeds[3];
				}
																		//For LeftJoyDir
									float pythag(float a, float b)
									{
										float c = sqrt( (a*a) + (b*b) );
										if (c < tol && c > -tol)
										{
											return 0;
										}
										else
										{
											return c;
										}
									}
									float arcTangent(float adj, float opp)
									{
										if (adj == 0)
										{
											adj = 0.01;
										}
										float degree = atan(opp / adj);

										if (degree < tol && degree > -tol)	//Tolerance for drift
										{
											degree = 0;
										}

										if 			(!(abs(adj) == adj) && abs(opp) != opp)	//Quad 2, -adj +opp
										{
											degree = -degree;
										}
										else if (!(abs(adj) == adj) && abs(opp) != -opp)	//Quad 3, -adj -opp
										{
											degree = -degree - 90;
										}
										else if (abs(adj) == adj 	&& abs(opp) != -opp)	//Quad 4, +adj -opp
										{
											degree += 90;
										}

										return degree;	//Adjust for quadrents
									}
									float cosine(float hyp, float degree)
									{
										float adj = hyp * cos(degree); //Lateral movement speed is the bot's lateralMag times cosine of the lateralDir
										/*if (abs(degree) != degree)
										{
											adj *= -1;	//Flip to negative
										}*/
										if (adj < tol && adj > -tol)
										{
											adj = 0;	//Round to zero
										}
										return adj;
									}//For LeftJoyDir

							//For determineLat
							float leftJoyDir()
							{
								return arcTangent(vexRT[Ch3], vexRT[Ch4]);
							}
							float leftJoyMag()
							{
									return pythag(vexRT[Ch3], vexRT[Ch4]);
							}//For determineLat

				//For addLatRot
				void determineLat()
				{
					float latTargetDir = (leftJoyDir());	//Get left joystick direction & magnitude
					float latTargetMag = (leftJoyMag());

					for (int i = 0; i < 4; i++)
					{
						lateralMag[i] = cosine(latTargetMag, abs(motorAngle[i] - latTargetDir) );	//Cosine of magnitude and degree
					}
				}
				void determineRot()
				{
					if (vexRT[Ch1] <= tol && vexRT[Ch1] >= -tol)
					{
						rotateMag = 0;
					}
					else
					{
						rotateMag = vexRT[Ch1]; //Ch1 Percent
					}
				}//For addLatRot


		void addLatRot()
		{
			for (int i = 0; i < 4; i++)
			{
				percent[i] = (lateralMag[i] /*(+ rotateMag*/) / 127;	//The percent speed each motor should travel at, between 200% and -200%
			}
		}
		void convertForTargetSpeed()
		{
			float denom = 1.00;		//Percents are out of 100% by default
			for (int i = 0; i < 4; i++)
			{
				percent[i] = percent[i] * powerMult[i];	//Apply the multiplier for fast/slow motors
				if ( abs(percent[i]) > denom)	//if the percent is greater than the denominator, yielding more than 100%
				{
					denom = abs(percent[i]);	//make the denominator equal to the new percent, so no value is more than 100%
				}
			}
			for (int i = 0; i < 4; i++)
			{
				targetSpeeds[i] = (percent[i] / denom) * botMaxSpeed;	//The target speed is a value between 0 and 1 representing the percent
			}																												//times the max speed the bot should ever travel at
		}
		void convertAndOutputSmoothSpeed()
		{
			for (int i = 0; i < 4; i++)
			{
				smoothSpeeds[i] = targetSpeeds[i]; //lerp(smoothSpeeds[i], targetSpeeds[i], speedSmoothing);	//Find the speed with acceleration
			}
			updateMotors();
		}


void calculateAll()
{
	determineLat();
	determineRot();

	addLatRot();

	convertForTargetSpeed();

	convertAndOutputSmoothSpeed();
}
void stopAll()
{
	for (int i = 0; i < 4; i++)
	{
		smoothSpeeds[i] = 0; //Stop all motors instantly
	}
	updateMotors();
}


/*----------------*\
|*			Main			*|
\*----------------*/

task main()
{
	while	(true)
	{
		if (vexRT[Btn5U] && vexRT[Btn6U])
		{
			eStopState = false;
			//ledEnable = 3;	//ON
			//ledESTOP = 1;	//Slow Blink
			while (!eStopState)
			{
				if (SensorValue(ESTOPbtn) == 1 || vexRT[Btn5D] == 1 || vexRT[Btn6D] == 1 || vexRT[Btn7D] == 1 || vexRT[Btn8D] == 1)
				{
					eStopState = true;
					//ledESTOP = 3;	//ON
					//ledEnable = 0;	//OFF
				}

				if (!eStopState)
				{
					calculateAll();

					/*if (hybernate)
					{
						wait1Msec(1000 / 2); //2 ticks per second
					}
					else
					{*/
						wait1Msec(1000 / tps);	//Msec per tick, inverse of ticks per second
					//}
				}
				else
				{
					stopAll();
				}

			}	//While Enable

		}	//Check for Enable

	}	//While Wait For Enable
}	//Task Main
