#pragma config(Sensor, dgtl1,  NEencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  SEencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  SWencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  NWencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  ESTOPbtn,       sensorTouch)
#pragma config(Sensor, dgtl10, ,               sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, lampENABLE,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, lampESTOP,      sensorLEDtoVCC)
#pragma config(Motor,  port3,           NE,            tmotorVex393_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port4,           SE,            tmotorVex393_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port5,           SW,            tmotorVex393_MC29, openLoop, encoderPort, dgtl5)
#pragma config(Motor,  port6,           NW,            tmotorVex393_MC29, openLoop, encoderPort, dgtl7)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*----------------*\
|*			SETUP			*|
\*----------------*/

const float tps = 10;
const float tol = 20;

bool eStopState = false;


//Speeds
float targetSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};
float smoothSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};



/*----------------*\
|*		FUNCTIONS		*|
\*----------------*/

				void updateMotors()
				{
					motor[NE] = smoothSpeeds[0];
					motor[SE] = smoothSpeeds[1];
					motor[SW] = smoothSpeeds[2];
					motor[NW] = smoothSpeeds[3];
				}

				float calcX()
				{
					float x = vexRT[Ch4];
					if (x < tol && x > -tol)
					{
						x = 0.0;
					}
					return x;
				}
				float calcY()
				{
					float y = vexRT[Ch3];
					if (y < tol && y > -tol)
					{
						y = 0.0;
					}
					return y;
				}
				float calcRot()
				{
					float rot = vexRT[Ch1];
					if (rot < tol && rot > -tol)
					{
						rot = 0.0;
					}
					return rot;
				}

		void addTar(float x, float y, float rot)
		{
			targetSpeeds[0] = (-y + x + rot) / 3;
			targetSpeeds[1] = (-y - x + rot) / 3;
			targetSpeeds[2] = ( y - x + rot) / 3;
			targetSpeeds[3] = ( y + x + rot) / 3;
		}



		void convertAndOutputSmoothSpeed()
		{
			for (int i = 0; i < 4; i++)
			{
				smoothSpeeds[i] = targetSpeeds[i]; //lerp(smoothSpeeds[i], targetSpeeds[i], speedSmoothing);	//Find the speed with acceleration
			}
			updateMotors();
		}

void calculateAll()
{
	//float xTar = calcX();
	//float yTar = calcY();
	//float rotTar = calcRot();

	addTar( calcX(), calcY(), calcRot() );

	convertAndOutputSmoothSpeed();
}
void stopAll()
{
	for (int i = 0; i < 4; i++)
	{
		smoothSpeeds[i] = 0; //Stop all motors instantly
	}
	updateMotors();
}


/*----------------*\
|*			Main			*|
\*----------------*/

task main()
{
	while	(true)
	{
		if (vexRT[Btn5U] && vexRT[Btn6U])
		{
			eStopState = false;
			//ledEnable = 3;	//ON
			//ledESTOP = 1;	//Slow Blink
			while (!eStopState)
			{
				if (SensorValue(ESTOPbtn) == 1 || vexRT[Btn5D] == 1 || vexRT[Btn6D] == 1 || vexRT[Btn7D] == 1 || vexRT[Btn8D] == 1)
				{
					eStopState = true;
					//ledESTOP = 3;	//ON
					//ledEnable = 0;	//OFF
				}

				if (!eStopState)
				{
					calculateAll();

					wait1Msec(1000 / tps);	//Msec per tick, inverse of ticks per second
				}
				else
				{
					stopAll();
				}

			}	//While Enable

		}	//Check for Enable

	}	//While Wait For Enable
}	//Task Main
