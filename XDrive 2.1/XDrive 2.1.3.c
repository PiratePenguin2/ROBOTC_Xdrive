#pragma config(Sensor, dgtl1,  NEencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  SEencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  SWencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  NWencoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  ESTOPbtn,       sensorTouch)
#pragma config(Sensor, dgtl10, ,               sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, lampENABLE,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, lampESTOP,      sensorLEDtoVCC)
#pragma config(Motor,  port3,           NE,            tmotorVex393_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port4,           SE,            tmotorVex393_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port5,           SW,            tmotorVex393_MC29, openLoop, encoderPort, dgtl5)
#pragma config(Motor,  port6,           NW,            tmotorVex393_MC29, openLoop, encoderPort, dgtl7)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*----------------*\
|*			SETUP			*|
\*----------------*/

const float tps = 10;
const float speedSmoothing = 1;

//Convert
string motorName[4] ={
	"NE",
	"SE",
	"SW",
	"NW",
};

//Speeds
float targetSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};
float smoothSpeeds[4] ={
	0.0, 0.0, 0.0, 0.0
};



/*----------------*\
|*		FUNCTIONS		*|
\*----------------*/
		float lerp(float a, float b, float weight)	//Acceleration equation
		{
			return a * (1 - weight) + b*weight;
		}

		void updateMotors()
		{
			motor[NE] = smoothSpeeds[0];
			motor[SE] = smoothSpeeds[1];
			motor[SW] = smoothSpeeds[2];
			motor[NW] = smoothSpeeds[3];
		}

	void convertForTargetSpeed()	//string motorName, float percent, float powerMult, float botMaxSpeed
	{
		for (int i = 0; i < 4; i++)
		{
			targetSpeeds[i] = 50;	//The target speed is a value between 0 and 1 representing the percent
		}												//times the max speed the bot should ever travel at
	}

	void convertAndOutputSmoothSpeed()
	{
		for (int i = 0; i < 4; i++)
		{
			smoothSpeeds[i] = lerp(smoothSpeeds[i], targetSpeeds[i], speedSmoothing);	//Find the speed with acceleration
		}
		updateMotors();
	}

void calculateAll()
{
	convertForTargetSpeed();

	convertAndOutputSmoothSpeed();
}

/*----------------*\
|*			Main			*|
\*----------------*/

task main()
{
	while	(true)
	{
		calculateAll();

		wait1Msec(1000 / tps);	//Msec per tick, inverse of ticks per second
	}

}
